// Generated by CoffeeScript 1.12.4
var Event, Gesture, Responder, ResponderList, ResponderMixin, ResponderSyntheticEvent, Type, assertType, emptyFunction, isDev, type;

ResponderSyntheticEvent = require("react-native/lib/ResponderSyntheticEvent");

emptyFunction = require("emptyFunction");

assertType = require("assertType");

Event = require("eve");

isDev = require("isDev");

Type = require("Type");

ResponderList = require("./ResponderList");

Gesture = require("./Gesture");

type = Type("Responder");

type.defineArgs(function() {
  return {
    types: {
      shouldRespondOnStart: Function,
      shouldRespondOnMove: Function,
      shouldCaptureOnStart: Function,
      shouldCaptureOnMove: Function,
      shouldTerminate: Function
    },
    defaults: {
      shouldRespondOnStart: emptyFunction.thatReturnsTrue,
      shouldRespondOnMove: emptyFunction.thatReturnsFalse,
      shouldCaptureOnStart: emptyFunction.thatReturnsFalse,
      shouldCaptureOnMove: emptyFunction.thatReturnsFalse,
      shouldTerminate: emptyFunction.thatReturnsTrue
    }
  };
});

type.defineValues(function() {
  return {
    touchHandlers: this._createTouchHandlers(),
    didReject: Event(),
    didGrant: Event(),
    didRelease: Event(),
    didTouchStart: Event(),
    didTouchMove: Event(),
    didTouchEnd: Event()
  };
});

type.defineGetters({
  touchCount: function() {
    return this._touchCount;
  },
  gesture: function() {
    return this._gesture;
  },
  isActive: function() {
    if (this._gesture) {
      return this._gesture.isActive;
    } else {
      return false;
    }
  },
  isGranted: function() {
    return this._isGranted;
  }
});

type.definePrototype({
  isEnabled: {
    get: function() {
      return this._isEnabled;
    },
    set: function(newValue, oldValue) {
      if (newValue !== oldValue) {
        this._isEnabled = newValue;
        this.terminate();
      }
    }
  }
});

type.defineMethods({
  join: function(responder) {
    var responders;
    if (Array.isArray(responder)) {
      responders = responder.filter(function(item) {
        return item instanceof Responder;
      });
      if (responders.length) {
        responders.unshift(this);
        return ResponderList(responders);
      }
      return this;
    }
    if (responder instanceof Responder) {
      return ResponderList([this, responder]);
    } else {
      return this;
    }
  },
  finish: function(nativeEvent) {
    return this._terminate(nativeEvent, true);
  },
  terminate: function(nativeEvent) {
    return this._terminate(nativeEvent, false);
  }
});

type.defineStatics({
  granted: Object.create(null),
  didGrant: Event(),
  didRelease: Event(),
  eventNames: {
    get: function() {
      return Object.keys(ResponderMixin);
    }
  }
});

type.defineHooks({
  __createGesture: Gesture,
  __shouldRespondOnStart: function(event) {
    return this._shouldRespondOnStart(this._gesture, event);
  },
  __shouldRespondOnMove: function(event) {
    return this._shouldRespondOnMove(this._gesture, event);
  },
  __shouldCaptureOnStart: function(event) {
    return this._shouldCaptureOnStart(this._gesture, event);
  },
  __shouldCaptureOnMove: function(event) {
    return this._shouldCaptureOnMove(this._gesture, event);
  },
  __onTouchStart: function(event) {
    this._gesture.__onTouchStart(event);
    this.didTouchStart.emit(this._gesture, event);
  },
  __onTouchMove: function(event) {
    this._gesture.__onTouchMove(event);
    this.didTouchMove.emit(this._gesture, event);
  },
  __onTouchEnd: function(event) {
    this._gesture.__onTouchEnd(event);
    this.didTouchEnd.emit(this._gesture, event);
  },
  __onReject: function(event) {
    this._gesture.__onReject(event);
    this.didReject.emit(this._gesture, event);
  },
  __onGrant: function(event) {
    this._gesture.__onGrant(event);
    this.didGrant.emit(this._gesture, event);
  },
  __onRelease: function(event, finished) {
    this._gesture.__onRelease(event, finished);
    this.didRelease.emit(this._gesture, event);
  },
  __onTerminationRequest: function(event) {
    if (this._gesture) {
      return this._shouldTerminate(this._gesture, event);
    } else {
      return true;
    }
  }
});

type.defineValues(function(options) {
  return {
    _touchCount: 0,
    _shouldRespondOnStart: options.shouldRespondOnStart,
    _shouldRespondOnMove: options.shouldRespondOnMove,
    _shouldCaptureOnStart: options.shouldCaptureOnStart,
    _shouldCaptureOnMove: options.shouldCaptureOnMove,
    _shouldTerminate: options.shouldTerminate
  };
});

type.defineReactiveValues({
  _isEnabled: true,
  _isGranted: false,
  _gesture: null
});

type.defineMethods({
  _createTouchHandlers: function() {
    var handler, handlers, key;
    handlers = {};
    for (key in ResponderMixin) {
      handler = ResponderMixin[key];
      handlers[key] = handler.bind(this);
    }
    return handlers;
  },
  _updateTouchCount: function(event) {
    var numberActiveTouches;
    numberActiveTouches = event.nativeEvent.touchHistory.numberActiveTouches;
    if (this._touchCount !== numberActiveTouches) {
      this._touchCount = numberActiveTouches;
      return true;
    }
    return false;
  },
  _grant: function(event) {
    this._isGranted = true;
    this.__onGrant(event);
    Responder.granted[this._gesture.target] = this;
    Responder.didGrant.emit(this, event);
  },
  _release: function(event, finished) {
    if (isDev && !this._isGranted) {
      throw Error("Cannot call '_release' when '_isGranted' equals false!");
    }
    if (isDev && this._touchCount > 0) {
      throw Error("Cannot call '_release' when '_touchCount' is greater than zero!");
    }
    this._isGranted = false;
    this._gesture.finished = finished;
    this.__onRelease(event, finished);
    this.__onTouchEnd(event);
    delete Responder.granted[this._gesture.target];
    Responder.didRelease.emit(this, event, finished);
    this._gesture = null;
  },
  _terminate: function(nativeEvent, finished) {
    var event;
    if (!this.isActive) {
      return;
    }
    this._touchCount = 0;
    if (nativeEvent == null) {
      nativeEvent = {};
    }
    if (nativeEvent.target == null) {
      nativeEvent.target = this._gesture.target;
    }
    if (nativeEvent.touches == null) {
      nativeEvent.touches = [];
    }
    if (nativeEvent.timestamp == null) {
      nativeEvent.timestamp = Date.now();
    }
    if (nativeEvent.touchHistory == null) {
      nativeEvent.touchHistory = this._gesture._touchHistory;
    }
    event = new ResponderSyntheticEvent(null, null, nativeEvent, nativeEvent.target);
    event.touchHistory = nativeEvent.touchHistory;
    if (this._isGranted) {
      this._release(event, finished);
      return;
    }
    this._gesture.finished = finished;
    this.__onTouchEnd(event);
    this._gesture = null;
  }
});

module.exports = Responder = type.build();

ResponderMixin = {
  onGestureStart: function(event) {
    if (this._isEnabled && !this._gesture) {
      this._gesture = this.__createGesture({
        target: event.nativeEvent.target,
        touchHistory: event.nativeEvent.touchHistory
      });
    }
  },
  onGestureEnd: function(event) {
    if (!this.isActive) {
      return;
    }
    this._gesture.finished = true;
    if (this._touchCount) {
      this._touchCount = 0;
      this.__onTouchEnd(event);
    }
    this._gesture = null;
  },
  onStartShouldSetResponder: function(event) {
    if (this._isEnabled && this.isActive) {
      return this.__shouldRespondOnStart(event);
    } else {
      return false;
    }
  },
  onMoveShouldSetResponder: function(event) {
    if (this._isEnabled && this.isActive) {
      return this.__shouldRespondOnMove(event);
    } else {
      return false;
    }
  },
  onStartShouldSetResponderCapture: function(event) {
    if (this._isEnabled && this.isActive) {
      this._updateTouchCount(event);
      this.__onTouchStart(event);
      return this.__shouldCaptureOnStart(event);
    }
    return false;
  },
  onMoveShouldSetResponderCapture: function(event) {
    if (this._isEnabled && this.isActive) {
      this.__onTouchMove(event);
      return this.__shouldCaptureOnMove(event);
    }
    return false;
  },
  onResponderStart: function(event) {
    if (!(this._isEnabled && this.isActive)) {
      return;
    }
    if (this._updateTouchCount(event)) {
      this.__onTouchStart(event);
    }
  },
  onResponderMove: function(event) {
    if (this._isEnabled && this.isActive) {
      this.__onTouchMove(event);
    }
  },
  onResponderEnd: function(event) {
    if (this._isEnabled && this.isActive) {
      this._updateTouchCount(event);
      this._touchCount && this.__onTouchEnd(event);
    }
  },
  onResponderReject: function(event) {
    if (this._isEnabled && this.isActive) {
      this.__onReject(event);
    }
  },
  onResponderGrant: function(event) {
    this._isGranted || this._grant(event);
    return true;
  },
  onResponderRelease: function(event) {
    if (this._isEnabled && this.isActive) {
      this._release(event, true);
    }
  },
  onResponderTerminate: function(event) {
    if (this._isEnabled && this.isActive) {
      this._touchCount = 0;
      this._release(event, false);
    }
  },
  onResponderTerminationRequest: function(event) {
    if (this._gesture) {
      return this.__onTerminationRequest(event);
    } else {
      return true;
    }
  }
};
