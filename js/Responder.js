// Generated by CoffeeScript 1.12.4
var Event, EventPluginHub, EventPluginUtils, Gesture, Responder, ResponderCache, ResponderEventPlugin, ResponderList, ResponderSyntheticEvent, TouchEvent, Type, assertType, emptyFunction, isDev, type;

ResponderSyntheticEvent = require("ResponderSyntheticEvent");

ResponderEventPlugin = require("ResponderEventPlugin");

EventPluginUtils = require("EventPluginUtils");

EventPluginHub = require("EventPluginHub");

ResponderCache = require("ResponderCache");

emptyFunction = require("emptyFunction");

assertType = require("assertType");

Event = require("eve");

isDev = require("isDev");

Type = require("Type");

ResponderList = require("./ResponderList");

Gesture = require("./Gesture");

TouchEvent = (function() {
  var types;
  types = {
    gesture: Gesture.Kind,
    event: ResponderSyntheticEvent
  };
  return function() {
    return Event({
      types: types
    });
  };
})();

type = Type("Responder");

type.defineArgs(function() {
  return {
    types: {
      shouldRespondOnStart: Function,
      shouldRespondOnMove: Function,
      shouldRespondOnEnd: Function,
      shouldCaptureOnStart: Function,
      shouldCaptureOnMove: Function,
      shouldCaptureOnEnd: Function,
      shouldTerminate: Function
    },
    defaults: {
      shouldRespondOnStart: emptyFunction.thatReturnsTrue,
      shouldRespondOnMove: emptyFunction.thatReturnsFalse,
      shouldRespondOnEnd: emptyFunction.thatReturnsFalse,
      shouldCaptureOnStart: emptyFunction.thatReturnsFalse,
      shouldCaptureOnMove: emptyFunction.thatReturnsFalse,
      shouldCaptureOnEnd: emptyFunction.thatReturnsFalse,
      shouldTerminate: emptyFunction.thatReturnsTrue
    }
  };
});

type.defineValues(function(options) {
  return {
    didReject: TouchEvent(),
    didGrant: TouchEvent(),
    didRelease: TouchEvent(),
    didTouchStart: TouchEvent(),
    didTouchMove: TouchEvent(),
    didTouchEnd: TouchEvent(),
    _shouldRespondOnStart: options.shouldRespondOnStart,
    _shouldRespondOnMove: options.shouldRespondOnMove,
    _shouldRespondOnEnd: options.shouldRespondOnEnd,
    _shouldCaptureOnStart: options.shouldCaptureOnStart,
    _shouldCaptureOnMove: options.shouldCaptureOnMove,
    _shouldCaptureOnEnd: options.shouldCaptureOnEnd,
    _shouldTerminate: options.shouldTerminate
  };
});

type.defineProperties({
  isEnabled: {
    value: true,
    reactive: true,
    didSet: function() {
      return this.terminate();
    }
  },
  touchHandlers: {
    lazy: function() {
      return this._createMixin();
    }
  },
  _gesture: {
    value: null,
    reactive: true
  },
  _isGranted: {
    value: false,
    reactive: true,
    didSet: function(newValue, oldValue) {
      if (newValue === oldValue) {
        return;
      }
      if (newValue) {
        Responder.granted[this._gesture.target] = this;
        return Responder.didGrant.emit(this);
      } else {
        delete Responder.granted[this._gesture.target];
        return Responder.didRelease.emit(this);
      }
    }
  }
});

type.defineGetters({
  gesture: function() {
    return this._gesture;
  },
  isActive: function() {
    if (this._gesture) {
      return this._gesture.isActive;
    } else {
      return false;
    }
  },
  isGranted: function() {
    return this._isGranted;
  }
});

type.defineMethods({
  join: function(responder) {
    var responders;
    if (Array.isArray(responder)) {
      responders = responder.filter(function(item) {
        return item instanceof Responder;
      });
      if (responders.length) {
        responders.unshift(this);
        return ResponderList(responders);
      }
      return this;
    }
    if (responder instanceof Responder) {
      return ResponderList([this, responder]);
    } else {
      return this;
    }
  },
  finish: function(nativeEvent) {
    var event;
    assertType(nativeEvent, Object.Maybe);
    if (this.isActive) {
      event = this._createEvent(nativeEvent);
      this._gestureEnded(event, true);
    }
  },
  terminate: function(nativeEvent) {
    var event;
    assertType(nativeEvent, Object.Maybe);
    if (this.isActive) {
      event = this._createEvent(nativeEvent);
      this._gestureEnded(event, false);
    }
  },
  _createEvent: function(nativeEvent) {
    var dispatchConfig, dispatchMarker;
    if (nativeEvent == null) {
      nativeEvent = {};
    }
    if (nativeEvent.touches == null) {
      nativeEvent.touches = [];
    }
    return new ResponderSyntheticEvent(dispatchConfig = {}, dispatchMarker = "", nativeEvent, nativeEvent.target);
  },
  _gestureBegan: function(arg) {
    var nativeEvent;
    nativeEvent = arg.nativeEvent;
    if (isDev && this._gesture) {
      throw Error("Must reset '_gesture' before calling '_gestureBegan'!");
    }
    this._gesture = this.__createGesture({
      target: nativeEvent.target,
      touchHistory: nativeEvent.touchHistory
    });
    if (isDev) {
      assertType(this._gesture, Gesture.Kind);
    }
  },
  _gestureEnded: function(event, finished) {
    if (isDev && !this._gesture) {
      throw Error("Must call '_gestureBegan' before '_gestureEnded'!");
    }
    if (isDev && !this._gesture.isActive) {
      throw Error("Must only call '_gestureEnded' once!");
    }
    this.__onTouchEnd(event);
    if (this._isGranted) {
      this._isGranted = false;
      this.__onRelease(event, finished);
    } else {
      this._gesture.__onRelease(event, finished);
    }
    this._gesture = null;
  },
  _createMixin: function() {
    return (function(_this) {
      return function() {
        return {
          onStartShouldSetResponder: function(event) {
            if (!_this._gesture) {
              _this._gestureBegan(event);
            }
            if (_this.__canUpdate()) {
              return _this.__shouldRespondOnStart(event);
            } else {
              return false;
            }
          },
          onMoveShouldSetResponder: function(event) {
            if (_this.__canUpdate()) {
              return _this.__shouldRespondOnMove(event);
            } else {
              return false;
            }
          },
          onStartShouldSetResponderCapture: function(event) {
            _this._gesture || _this._gestureBegan(event);
            if (_this.__canUpdate()) {
              _this.__onTouchStart(event);
              return _this.__shouldCaptureOnStart(event);
            }
            return false;
          },
          onMoveShouldSetResponderCapture: function(event) {
            if (_this.__canUpdate()) {
              _this.__onTouchMove(event);
              return _this.__shouldCaptureOnMove(event);
            }
            return false;
          },
          onResponderStart: function(event) {
            if (_this.__canUpdate()) {
              _this.__onTouchStart(event);
            }
          },
          onResponderMove: function(event) {
            if (_this.__canUpdate()) {
              _this.__onTouchMove(event);
            }
          },
          onResponderEnd: function(event) {
            if (_this._isGranted) {
              if (!_this.__canUpdate()) {
                return;
              }
              _this.__onTouchEnd(event);
            } else if (_this.isActive && _this._gesture.touchHistory.numberActiveTouches === 0) {
              _this._gestureEnded(event, true);
            }
          },
          onResponderReject: function(event) {
            if (_this.__canUpdate()) {
              _this.__onReject(event);
              _this._gestureEnded(event, false);
            }
          },
          onResponderGrant: function(event) {
            if (!_this._isGranted) {
              _this._isGranted = true;
              _this.__onGrant(event);
            }
            return true;
          },
          onResponderRelease: function(event) {
            if (_this.__canUpdate()) {
              _this._gestureEnded(event, true);
            }
          },
          onResponderTerminate: function(event) {
            if (_this.__canUpdate()) {
              _this._gestureEnded(event, false);
            }
          },
          onResponderTerminationRequest: function(event) {
            if (_this._gesture) {
              return _this.__onTerminationRequest(event);
            } else {
              return true;
            }
          }
        };
      };
    })(this)();
  }
});

type.defineHooks({
  __canUpdate: function() {
    return this.isEnabled && this.isActive;
  },
  __createGesture: function(options) {
    return Gesture(options);
  },
  __shouldRespondOnStart: function(event) {
    return this._shouldRespondOnStart(this._gesture, event);
  },
  __shouldRespondOnMove: function(event) {
    return this._shouldRespondOnMove(this._gesture, event);
  },
  __shouldRespondOnEnd: function(event) {
    return this._shouldRespondOnEnd(this._gesture, event);
  },
  __shouldCaptureOnStart: function(event) {
    return this._shouldCaptureOnStart(this._gesture, event);
  },
  __shouldCaptureOnMove: function(event) {
    return this._shouldCaptureOnMove(this._gesture, event);
  },
  __shouldCaptureOnEnd: function(event) {
    return this._shouldCaptureOnEnd(this._gesture, event);
  },
  __onTouchStart: function(event) {
    this._gesture.__onTouchStart(event);
    return this.didTouchStart.emit(this._gesture, event);
  },
  __onTouchMove: function(event) {
    this._gesture.__onTouchMove(event);
    return this.didTouchMove.emit(this._gesture, event);
  },
  __onTouchEnd: function(event) {
    this._gesture.__onTouchEnd(event);
    return this.didTouchEnd.emit(this._gesture, event);
  },
  __onReject: function(event) {
    this._gesture.__onReject(event);
    return this.didReject.emit(this._gesture, event);
  },
  __onGrant: function(event) {
    this._gesture.__onGrant(event);
    return this.didGrant.emit(this._gesture, event);
  },
  __onRelease: function(event, finished) {
    this._gesture.__onRelease(event, finished);
    return this.didRelease.emit(this._gesture, event);
  },
  __onTerminationRequest: function(event) {
    if (!this._gesture) {
      return true;
    }
    return this._shouldTerminate(this._gesture, event);
  }
});

type.defineStatics({
  granted: Object.create(null),
  didGrant: Event(),
  didRelease: Event(),
  eventNames: ["onStartShouldSetResponder", "onStartShouldSetResponderCapture", "onMoveShouldSetResponder", "onMoveShouldSetResponderCapture", "onResponderReject", "onResponderGrant", "onResponderStart", "onResponderMove", "onResponderEnd", "onResponderRelease", "onResponderTerminate", "onResponderTerminationRequest"]
});

module.exports = Responder = type.build();

ResponderEventPlugin.injection.injectGlobalTouchHandler({
  onTouchEnd: function(event) {
    var i, index, instances, len, listener, listeners, parentInst, target, targetInst, touchHistory;
    target = event.target, touchHistory = event.touchHistory;
    targetInst = EventPluginUtils.getInstanceFromNode(target);
    parentInst = ResponderCache.hasResponder(targetInst) ? EventPluginUtils.getParentInstance(targetInst) : targetInst;
    listeners = [];
    instances = [];
    while (parentInst !== null) {
      if (listener = EventPluginHub.getListener(parentInst, "onResponderEnd")) {
        listeners.push(listener);
        instances.push(parentInst);
      }
      parentInst = EventPluginUtils.getParentInstance(parentInst);
    }
    for (index = i = 0, len = listeners.length; i < len; index = ++i) {
      listener = listeners[index];
      listener(event, instances[index]);
    }
  }
});
